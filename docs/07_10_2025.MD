ChatGPT said:
Frontend Development Overview

The project’s frontend is developed using Angular, which communicates with the Django backend to provide the Threat Evaluation & Weapon Assignment (TEWA) system. The data flows between the backend and frontend through RESTful APIs exposed by Django, and the frontend is responsible for visualizing data such as threat scores, scenarios, defended assets (DAs), tracks, and track samples.

Key Frontend Tasks

Frontend Framework:
The frontend is developed using Angular (latest stable version) with TypeScript. Angular Material may be optionally used for UI components, and Leaflet is used for mapping and visualizing defended assets and tracks on the map.

UI Components:

Dashboard Component: Displays all scenarios, computes threat scores, and provides access to track uploads.

Track Upload Component: Allows users to upload CSV files containing track data, which is then processed by the backend and reflected in the frontend UI.

Threat Score Display: After computing threats, the frontend will show threat scores, the associated DA, track details, and ranking.

Ranking Table: Shows top-ranked threats and updates automatically using polling or manual refresh.

Scenario Details: Displays detailed information about the scenario, including associated tracks, threat scores, and other metadata.

Data Transactions and API Integration:
The frontend communicates with the backend through the following RESTful APIs exposed by Django:

Key APIs:

Scenario API (GET /api/tewa/scenarios/):
Retrieves all active scenarios from the backend. These scenarios will be shown in dropdowns or as a list in the UI.

Track Upload API (POST /api/tewa/upload_tracks/):
Allows the user to upload track data in CSV format. The backend processes the CSV, creates Track and TrackSample entries, and responds with the status of the upload.

Compute Threats API (POST /api/tewa/compute_at/ and POST /api/tewa/compute_now/):
Computes threat scores for the given tracks and DAs. The frontend sends a POST request to trigger the computation at a specific time or for the current time.

Ranking API (GET /api/tewa/ranking/):
Displays threat rankings after the compute process is complete. The frontend will periodically fetch this data to update the user interface in real-time.

Service Layer:
The service layer in Angular handles all API requests and responses. This includes methods to fetch data, send requests, handle responses, and manage error states. The service layer ensures that all API transactions happen asynchronously, with proper handling of success, failure, and loading states.

tewa.service.ts (Angular Service Example)

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { environment } from '../../../environments/environment';

@Injectable({
providedIn: 'root'
})
export class TewaService {

private apiBase = environment.apiBase; // '/api/tewa'

constructor(private http: HttpClient) { }

// Get all scenarios
getScenarios(): Observable<any> {
return this.http.get(`${this.apiBase}/scenarios/`);
}

// Upload track data
uploadTracks(file: File, scenarioId: number): Observable<any> {
const formData = new FormData();
formData.append('file', file);
formData.append('scenario_id', scenarioId.toString());
return this.http.post(`${this.apiBase}/upload_tracks/`, formData);
}

// Compute threats now
computeNow(scenarioId: number, weaponRangeKm: number): Observable<any> {
const payload = { scenario_id: scenarioId, weapon_range_km: weaponRangeKm };
return this.http.post(`${this.apiBase}/compute_now/`, payload);
}

// Get rankings
getRanking(scenarioId: number): Observable<any> {
return this.http.get(`${this.apiBase}/ranking/?scenario_id=${scenarioId}&top_n=10`);
}
}

Data Flow and Transactions

The overall data flow for the frontend is structured to provide a smooth and dynamic user experience:

Initialization:
When the frontend is initialized, it makes API calls to fetch all scenarios (/scenarios/), the list of defended assets (/defendedassets/), and any existing threat scores if available. This data is displayed in the UI for the user to interact with.

Track Upload:
The user selects a CSV file containing track data from their local machine and uploads it using the Track Upload Component. This file is sent to the backend via the POST /upload_tracks/ API.
The backend processes the file and creates or updates the Track and TrackSample entries. Upon success, the frontend receives a response indicating the number of tracks and samples processed.

Compute Threat Scores:
When the user initiates the threat computation (either immediately or at a scheduled time), the frontend sends a request to the backend to compute threat scores for the selected scenario.
The frontend can either compute immediately (POST /compute_now/) or at a specific timestamp (POST /compute_at/).
After computation, the backend responds with the computed threat scores, and the frontend updates the UI with these results.

Threat Score Ranking:
After computing the threat scores, the frontend periodically polls the Ranking API (GET /ranking/) to display the threat ranking. This ranking is updated in real-time based on the latest computation and provides the user with an overview of the highest-ranked threats.

Frontend Components and Layout

App Component
The root component (app.component.ts) will manage routing and will contain a small navigation panel for easy access to various features such as the dashboard, track upload, and computation.

Dashboard
Displays the list of scenarios and defended assets, with options to trigger computation. It also shows computed threat scores and rankings.

Track Upload
A form that allows the user to upload a CSV of track data. It uses Angular Material's file input or a custom drag-and-drop file uploader.

Compute Section
A section that lets the user initiate threat score computation. It allows computing either immediately or at a specific timestamp.

Ranking Table
Displays a list of the top threats, updated in real-time. The table shows track IDs, DA names, threat scores, and the timestamp when the score was computed.

Leaflet Map
Used to visualize defended assets (DAs) as circles on a map and tracks as markers. The map is interactive, and users can zoom and pan to see the DAs and tracks in geographical context.

Polling and Real-Time Updates

For the real-time threat score ranking:

Use Angular’s HttpClient to fetch data from the backend every few seconds using setInterval() or Angular's RxJS polling operators.

This ensures that the Ranking Table stays up-to-date without manual refreshes.

Example polling mechanism for ranking:

import { Component, OnInit } from '@angular/core';
import { TewaService } from './core/services/tewa.service';

@Component({
selector: 'app-ranking-table',
templateUrl: './ranking-table.component.html',
styleUrls: ['./ranking-table.component.css']
})
export class RankingTableComponent implements OnInit {
ranking: any[] = [];

constructor(private tewaService: TewaService) {}

ngOnInit(): void {
this.fetchRanking();
setInterval(() => {
this.fetchRanking();
}, 5000); // Poll every 5 seconds
}

fetchRanking(): void {
this.tewaService.getRanking(1).subscribe((data: any) => {
this.ranking = data.threats;
});
}
}

Conclusion

Frontend is built using Angular, making use of services for API interaction, Angular Material for UI components, and Leaflet for map visualizations.

Data flows from the backend through RESTful APIs and is dynamically updated in the UI.

Real-time updates are handled using polling for threat rankings, providing a smooth and interactive user experience.

The frontend integrates seamlessly with the Django backend through the API service layer.

This structure ensures that the frontend and backend communicate effectively and that the system is scalable for future enhancements.

Let me know if you need any adjustments or further explanations for your frontend team!
