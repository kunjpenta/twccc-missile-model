TEWA Project — Detailed Backend & Integration Summary

1. Project Overview

Project Name: TEWA (Threat Evaluation & Weapon Assignment)

Backend: Django + PostgreSQL

Frontend: Angular (currently using a proxy to connect to Django backend)

Purpose: To simulate, evaluate, and compute threat levels for aircraft/tracks against defended assets (DAs) using deterministic models (CPA, TCPA, TDB, TWRP).

2. Project Structure
   Backend (Django)

Root Folder: missile_model/

App Folder: tewa/
Contains all TEWA-specific models, views, serializers, services, and fixtures.

Core Folder: core/
Contains utilities and common functions shared across the project:

utils/ → units conversions, geodesy calculations

tests/ → unit tests for kinematics, scoring, geodesy, etc.

Backend Structure Example:

missile_model/
├── manage.py
├── missile_model/
│ └── settings.py, urls.py, wsgi.py
├── tewa/
│ ├── models.py # Core TEWA models (Track, TrackSample, Scenario, DA, ThreatScore, ModelParams)
│ ├── serializers.py # DRF serializers for API endpoints
│ ├── views.py # API endpoints for frontend
│ ├── urls.py # TEWA-specific URL routes
│ ├── services/ # Core business logic & calculations
│ │ ├── kinematics.py # CPA, TCPA, TDB, TWRP calculations
│ │ ├── scoring.py # Threat score normalization & computation
│ │ ├── engine.py # Scenario engine to compute scores per timestamp
│ │ └── sampling.py # Track state sampling at given timestamps
│ ├── management/commands/ # Django management commands
│ │ └── compute_threats.py # Periodic threat score computation
│ └── fixtures/ # Sample data for scenarios, tracks, DAs
├── core/
│ ├── utils/
│ │ ├── geodesy.py # ENU/local planar conversions, Haversine distance, bearing
│ │ └── units.py # Unit conversions (mps ↔ knots, m ↔ nm)
│ └── tests/ # Unit tests for kinematics, scoring, geodesy

3. Backend Models

We implemented all core TEWA models:

DefendedAsset (DA)

Fields: name, lat, lon, radius_km

Used to represent protected assets; DA boundary is critical for TDB/TWRP.

Validations for positive radius.

Scenario

Fields: name, description, start_time, end_time, notes

Groups tracks, DAs, and model parameters for a simulation.

Track

Fields: track_id, lat, lon, alt_m, speed_mps, heading_deg

Represents a moving aircraft/target.

TrackSample

Time-series snapshots of tracks.

Fields: t, lat, lon, alt_m, speed_mps, heading_deg

Indexed for performance on time queries.

ModelParams

Stores weights for CPA, TCPA, TDB, TWRP.

Includes normalization scales and optional clamping.

ThreatScore

Stores computed threat for a (Track, DA) at a timestamp.

Fields: cpa_km, tcpa_s, tdb_km, twrp_s, score, computed_at.

4. Core Backend Services
   4.1 Kinematics (kinematics.py)

Computes CPA (Closest Point of Approach) and TCPA (Time to CPA) using a local ENU frame.

Computes TDB (Time to DA Boundary) and TWRP (Time to Weapon Release Point).

Converts lat/lon to local ENU coordinates for fast computation.

Supports legacy wrappers for backward compatibility.

4.2 Threat Scoring (scoring.py)

Normalizes CPA/TCPA/TDB/TWRP values to 0–1.

Computes weighted threat score using ModelParams.

Provides runtime safety for optional or missing values.

4.3 Scenario Engine (engine.py)

Computes threat scores for all tracks in a scenario at a given timestamp.

Supports optional weapon range.

Returns a list of ThreatScore objects ready to store or return via API.

4.4 CSV Upload (views.py)

Endpoint /api/tewa/upload_tracks/

Parses CSV files to create Track and TrackSample entries.

Validates timestamps and numeric fields.

4.5 Periodic Compute (management/commands/compute_threats.py)

Management command to compute threat scores for all tracks/DAs.

Supports --scenario_id, --timestamp, and optional --weapon_range_km.

Can be scheduled via cron or Celery for periodic computation.

5. API Endpoints
   Endpoint Method Purpose Notes
   /api/tewa/scenarios/ GET List all scenarios Populate frontend dropdowns
   /api/tewa/upload_tracks/ POST Upload CSV for tracks File input in Angular
   /api/tewa/compute_now/ POST Compute threat scores immediately Input: scenario_id, timestamp, weapon_range_km
   /api/ GET API status Returns available endpoints
   /admin/ GET Django admin Manage models manually
6. Frontend Integration Requirements

Scenario Dropdown: Fetch /api/tewa/scenarios/.

CSV Upload: Send CSV to /api/tewa/upload_tracks/.

Compute Threat Scores: POST to /api/tewa/compute_now/.

Map Visualization:

DAs → circles with radius radius_km.

Tracks → markers or polylines, updated dynamically.

Color-code by threat score.

Table Display: Show CPA, TCPA, TDB, TWRP, final score for each track-DA pair.

7. Testing & Validation

Unit Tests: Core services (kinematics, scoring, sampling) tested in core/tests/.

Backend Tests: Verified CSV upload, scenario creation, and threat score computation.

Integration Ready: Backend endpoints are functional, returning proper JSON for frontend use.

8. Key Integration Notes

Timezone Handling

All timestamps must be ISO 8601 and timezone-aware.

Naive datetime warnings exist if timestamps are not converted correctly.

CSV Requirements

Columns: track_id, lat, lon, alt_m, speed_mps, heading_deg, timestamp

Timestamp must be ISO 8601 UTC.

Frontend Proxy

Angular uses /api proxy to connect to Django backend at http://127.0.0.1:8000.

Data Flow

Scenario selected → tracks uploaded via CSV → compute threat scores → display on map and table.

This document encapsulates all backend logic, file structure, APIs, data models, services, and frontend integration points so another AI or developer can fully understand the system and provide answers or continue development.

TEWA Project: Frontend Integration Guide

1. Overview

The Threat Evaluation & Weapon Assignment (TEWA) project is a backend system designed to compute threat scores based on the real-time positions of aircraft, defended assets (DAs), and weapon ranges. The system consists of two main components:

Backend (Django API): Manages threat score computation, data storage (e.g., Defended Assets, Tracks), and scenario management.

Frontend (Angular UI): Allows users to upload track data, compute threat scores, and visualize data (e.g., rankings, maps, scenarios).

This document outlines how the frontend team can interact with the backend and integrate it seamlessly.

2. Project Components
   Backend (Django)

Core Models:

Scenario: Represents a combat scenario.

DefendedAsset: Represents the defended area (e.g., military base, city).

Track: Represents an aircraft or object in a scenario.

TrackSample: Stores the position of the Track at a specific time.

ThreatScore: Represents the computed score of the threat posed by a track to a defended asset.

Frontend (Angular)

Main Components:

Dashboard: Displays all scenarios, tracks, and threat scores.

Track Upload: Allows users to upload track data via CSV files.

Compute Threats: A button to compute threat scores either immediately or at a given timestamp.

Ranking Table: Displays the ranking of threats by computed score.

Leaflet Map: Displays the DAs and Tracks on an interactive map.

3. API Endpoints Overview

The backend exposes several RESTful APIs that the frontend will use to interact with the system. Below is a list of the main APIs that the frontend will call:

3.1 Scenario APIs

GET /api/tewa/scenarios/
Fetches a list of all available scenarios for display in the UI (e.g., Demo-Scenario, Scenario-2, Scenario-3).

Response Example:

[
{
"id": 1,
"name": "Demo-Scenario",
"start_time": "2025-09-30T06:00:00Z",
"end_time": null,
"notes": "Seeded demo scenario for TEWA."
},
{
"id": 2,
"name": "Scenario-2",
"start_time": null,
"end_time": null,
"notes": null
}
]

3.2 Track Upload API

POST /api/tewa/upload_tracks/
Uploads a CSV file containing track data and associates it with a specific scenario.

Request Example (Frontend sends the file):

{
"file": "track_data.csv",
"scenario_id": 1
}

Response Example:

{
"message": "Upload successful",
"tracks_created": 3,
"samples_created": 9,
"rows_processed": 12
}

3.3 Threat Computation APIs

POST /api/tewa/compute_now/
Computes the threat score for tracks in a scenario at the current time.

Request Example:

{
"scenario_id": 1,
"weapon_range_km": 20
}

POST /api/tewa/compute_at/
Computes threat scores for tracks in a scenario at a specific timestamp.

Request Example:

{
"scenario_id": 1,
"when": "2025-09-30T06:07:30Z",
"weapon_range_km": 20
}

3.4 Ranking API

GET /api/tewa/ranking/
Fetches the threat ranking for a specific scenario.

Request Example:

{
"scenario_id": 1,
"top_n": 10
}

Response Example:

{
"scenario_id": 1,
"threats": [
{
"track_id": "T2",
"da_name": "DA-Alpha (Jaisalmer)",
"score": 0.7617,
"computed_at": "2025-10-01T07:23:01Z"
},
{
"track_id": "T1",
"da_name": "DA-Alpha (Jaisalmer)",
"score": 0.5785,
"computed_at": "2025-10-01T07:23:01Z"
}
]
}

4. Data Flow & Interaction Between Frontend and Backend

Initialization:
The frontend initializes by fetching all available scenarios and DAs. This data is used to populate dropdowns or lists for user selection.

Fetch all scenarios using the GET /api/tewa/scenarios/ API.

Fetch the defended assets (DAs) by either fetching the full list or ensuring DA-Alpha and DA-Bravo are present.

Track Upload:
The user selects a CSV file containing track data. This file is uploaded to the backend using the POST /api/tewa/upload_tracks/ API. The server processes the file and stores the data in the database.

Compute Threat Scores:
The frontend provides the user with the ability to compute the threat scores:

Immediate computation: The user clicks the "Compute Now" button, which sends a POST /api/tewa/compute_now/ request to compute threat scores based on the current time.

Scheduled computation: The user can also specify a timestamp to compute the threat scores at a future time using POST /api/tewa/compute_at/.

Display Ranking:
Once threat scores are computed, the frontend periodically fetches updated rankings using the GET /api/tewa/ranking/ API to display the top-ranked threats in real-time.

Map Visualization:
The frontend will display the DAs and Tracks on a map using Leaflet.js. The DAs will be shown as circles, and the Tracks will be shown as markers with their respective track IDs and headings.

5. Frontend Integration Steps

Set Up Angular Service for API Calls
Implement an Angular service (tewa.service.ts) to handle API communication.

Upload Track Data
Create a component to allow users to upload track data via a file input field. Use Angular Material’s file input or a custom drag-and-drop component.

Trigger Compute Threats
Create a UI button that triggers the compute request when clicked. The frontend should either send a POST request for immediate computation or allow the user to specify a timestamp.

Display Results

Compute results: Display the computed threat scores.

Ranking table: Show a ranking of the highest threats, refreshed regularly using RxJS polling.

Visualize Data on Map

Integrate Leaflet to show DAs and Tracks on an interactive map.

DAs are displayed as circles, and Tracks as markers. Add interactivity like click events to show more details.

6. Example Code Snippets for Frontend
   TewaService (API Service Layer)
   @Injectable({
   providedIn: 'root'
   })
   export class TewaService {
   private apiBase = '/api/tewa';

constructor(private http: HttpClient) { }

// Get all scenarios
getScenarios(): Observable<any> {
return this.http.get(`${this.apiBase}/scenarios/`);
}

// Upload tracks
uploadTracks(file: File, scenarioId: number): Observable<any> {
const formData = new FormData();
formData.append('file', file);
formData.append('scenario_id', scenarioId.toString());
return this.http.post(`${this.apiBase}/upload_tracks/`, formData);
}

// Compute threats now
computeNow(scenarioId: number, weaponRangeKm: number): Observable<any> {
const payload = { scenario_id: scenarioId, weapon_range_km: weaponRangeKm };
return this.http.post(`${this.apiBase}/compute_now/`, payload);
}

// Get threat ranking
getRanking(scenarioId: number): Observable<any> {
return this.http.get(`${this.apiBase}/ranking/?scenario_id=${scenarioId}&top_n=10`);
}
}

Scenario Component (Display Scenarios and Trigger Compute)
@Component({
selector: 'app-scenario-dashboard',
templateUrl: './scenario-dashboard.component.html',
styleUrls: ['./scenario-dashboard.component.css']
})
export class ScenarioDashboardComponent implements OnInit {
scenarios: any[] = [];

constructor(private tewaService: TewaService) {}

ngOnInit(): void {
this.tewaService.getScenarios().subscribe((scenarios) => {
this.scenarios = scenarios;
});
}

// Trigger compute now
computeNow(scenarioId: number): void {
this.tewaService.computeNow(scenarioId, 20).subscribe(response => {
console.log('Threat computation successful:', response);
});
}
}

7. Conclusion

This guide provides a complete understanding of how the frontend will interact with the backend through the API, handle data transactions, and visualize the results. The integration involves uploading track data, triggering computation, fetching rankings, and displaying results in a dynamic and interactive UI.

Task: CSV Import (Tracks), DA Geometry, Periodic Compute Command, and Manual Compute Trigger

1. CSV Import (Tracks)

Objective:

Implement functionality for uploading track data in CSV format and automatically parsing the CSV to create Track and TrackSample entries in the database.

Frontend Interaction:

The frontend will provide a user interface (UI) for uploading CSV files containing track data.

The user will upload a CSV file, which the frontend will send to the backend via a POST request to the /api/tewa/upload_tracks/ endpoint.

The response from the backend will indicate how many tracks and track samples were created successfully.

Backend Interaction:

The backend (Django) will receive the uploaded CSV file, parse it, and create corresponding Track and TrackSample records in the database.

A sample CSV file might look like this:

track_id,lat,lon,alt_m,speed_mps,heading_deg
T1,28.9,77.4,3500,220,200
T2,28.7,77.1,3200,250,170
T3,28.5,77.6,4800,210,315

Database Schema:

Track: Includes fields like track_id, lat, lon, alt_m, speed_mps, heading_deg, and a foreign key to the Scenario model.

TrackSample: Stores specific points in time for a track, including fields like track (foreign key), lat, lon, alt_m, speed_mps, heading_deg, and a timestamp.

Verification:

The system should ensure that the Track and TrackSample records are properly created and associated with the correct Scenario and DefendedAsset.

2. DA Geometry (DefendedAsset Setup)

Objective:

Implement the creation and validation of DefendedAsset (DA) models, including validation for the radius of the defended area and geographical constraints (latitude, longitude).

Frontend Interaction:

The frontend will display a form for DefendedAsset creation, where the user can input values for name, latitude, longitude, and radius (in kilometers).

The frontend will send the user input data to the backend via a POST request to the /api/tewa/defendedasset/ endpoint.

Backend Interaction:

The backend will validate the DA's latitude and longitude to ensure they are within valid ranges (latitude between -90 and 90, longitude between -180 and 180).

The radius must be a positive number (0 < radius_km ≤ 1000).

Database Schema:

DefendedAsset: Includes fields like name, lat, lon, and radius_km.

Verification:

Ensure that the DefendedAsset creation form validates the geographical data (latitude, longitude, and radius).

Ensure the backend performs the appropriate validation checks.

3. Periodic Compute Command (compute_threats Management Command)

Objective:

Implement the compute_threats management command to periodically compute threat scores for all scenarios and defended assets.

Frontend Interaction:

No direct interaction with the frontend. This is a backend task that is triggered either manually via the Django admin panel or by an automated scheduler (Celery Beat).

Backend Interaction:

The compute_threats command computes threat scores for all tracks within each scenario and defended asset pair.

The backend computes CPA, TCPA, TDB, and TWRP for each track and defended asset pair, stores the computed threat score in the database, and updates the ThreatScore model.

The compute_threats command can be scheduled to run periodically via Celery Beat or triggered manually.

Command Execution:

To run the command manually:

python manage.py compute_threats

Verification:

Ensure that the command computes threat scores for each scenario and defended asset pair.

Ensure that the ThreatScore records are properly updated in the database.

4. Manual Compute Trigger (Compute Now Button)

Objective:

Implement a button in the frontend that triggers the compute_threats command to compute threat scores for selected scenarios manually.

Frontend Interaction:

The frontend will have a "Compute Now" button, which the user can click to initiate the threat score computation for the selected scenario.

The frontend will send a POST request to the backend at the /api/tewa/compute_now/ endpoint, passing the scenario_id and any other relevant parameters (e.g., weapon_range_km).

Backend Interaction:

When the "Compute Now" button is clicked, the frontend will trigger a POST request to the backend, which will compute threat scores immediately for the selected scenario.

Verification:

Ensure that clicking the "Compute Now" button in the frontend triggers the POST request to the backend and computes threat scores for the selected scenario.

Example Request:

{
"scenario_id": 1,
"weapon_range_km": 20
}

Example Response:

{
"status": "ok",
"message": "Threat scores computed successfully"
}

Summary for the Teams:

CSV Import (Tracks):

Frontend should provide a UI for uploading CSV files.

Backend processes the uploaded CSV and creates Track and TrackSample entries in the database.

DA Geometry (DefendedAsset Setup):

Frontend will allow the creation of DefendedAsset through a form.

Backend will validate latitude, longitude, and radius values to ensure they are within acceptable ranges.

Periodic Compute Command (compute_threats):

A backend task that computes threat scores periodically for all scenarios and defended assets.

Can be run manually or scheduled using Celery Beat.

Manual Compute Trigger (Compute Now Button):

Frontend will include a "Compute Now" button.

Clicking the button sends a POST request to the backend to trigger threat score computation for a selected scenario.

4. Frontend Integration

The frontend will call the Ranking API to retrieve the top-N ranked threats for a specific scenario. Here’s how the integration will happen:

4.1 Angular Service for Ranking

In the Angular frontend, you will create a service (tewa.service.ts) to call the backend API.

@Injectable({
providedIn: 'root'
})
export class TewaService {

private apiBase = '/api/tewa';

constructor(private http: HttpClient) { }

// Get ranking of threats
getRanking(scenarioId: number, topN: number): Observable<any> {
return this.http.get(`${this.apiBase}/ranking/?scenario_id=${scenarioId}&top_n=${topN}`);
}
}

4.2 Ranking Table Component

In the ranking-table.component.ts, the frontend will display the threats in a table, updated either manually or periodically by polling the backend.

@Component({
selector: 'app-ranking-table',
templateUrl: './ranking-table.component.html',
styleUrls: ['./ranking-table.component.css']
})
export class RankingTableComponent implements OnInit {
ranking: any[] = [];

constructor(private tewaService: TewaService) {}

ngOnInit(): void {
this.fetchRanking();
setInterval(() => {
this.fetchRanking();
}, 5000); // Poll every 5 seconds
}

fetchRanking(): void {
this.tewaService.getRanking(1, 10).subscribe((data: any) => {
this.ranking = data.threats;
});
}
}
Step 3: Test Frontend Integration

The Angular frontend will interact with this ranking service via the API. Here's how it should work:

3.1 Angular Service

Ensure the Angular service is implemented to fetch ranked threats from the API:

@Injectable({
providedIn: 'root'
})
export class TewaService {

private apiBase = '/api/tewa';

constructor(private http: HttpClient) { }

// Get ranking of threats
getRanking(scenarioId: number, topN: number): Observable<any> {
return this.http.get(`${this.apiBase}/ranking/?scenario_id=${scenarioId}&top_n=${topN}`);
}
}

3.2 Frontend Component

Ensure the frontend component that displays the ranking is connected to the Angular service:

@Component({
selector: 'app-ranking-table',
templateUrl: './ranking-table.component.html',
styleUrls: ['./ranking-table.component.css']
})
export class RankingTableComponent implements OnInit {
ranking: any[] = [];

constructor(private tewaService: TewaService) {}

ngOnInit(): void {
this.fetchRanking();
setInterval(() => {
this.fetchRanking();
}, 5000); // Poll every 5 seconds
}

fetchRanking(): void {
this.tewaService.getRanking(1, 5).subscribe((data: any) => {
this.ranking = data.threats;
});
}
} 3. Frontend Integration

Tewa Service: Your Angular service will call this API to fetch the ranked threats for a given scenario.

UI Display: Display the threats in a table sorted by score for each Defended Asset (DA) or globally.

Example of the Angular service:
@Injectable({
providedIn: 'root'
})
export class TewaService {

private apiBase = '/api/tewa';

constructor(private http: HttpClient) { }

// Get ranking of threats (top N)
getRanking(scenarioId: number, topN: number): Observable<any> {
return this.http.get(`${this.apiBase}/ranking/?scenario_id=${scenarioId}&top_n=${topN}`);
}
}

4. Conclusion

With this service implementation, you will now be able to:

Rank threats for both Defended Assets (DAs) and globally, based on threat scores.

Expose an API that returns the top-N ranked threats for a given scenario.

Integrate with the frontend to display ranked threats to the user.

Let me know if you'd like further clarifications or need more adjustments!

1. Overview of the Backend Setup
   Threat Ranking Service:

The backend now includes a ranking API for threats, which provides the following features:

API Endpoint: /api/tewa/ranking/

Parameters:

scenario_id: The ID of the scenario for which threats need to be ranked.

top_n: The number of threats to return (default is 10).

Example request:

curl -s "http://127.0.0.1:8000/api/tewa/ranking/?scenario_id=1&top_n=5" | jq .

Response Example:

{
"scenario_id": 1,
"ranked_threats": [
{
"da_name": "DA-Alpha",
"threats": [
{
"track_id": "T1",
"score": 0.9,
"computed_at": "2025-09-30T06:00:00Z"
}
]
},
{
"da_name": "DA-Bravo",
"threats": [
{
"track_id": "T1",
"score": 0.8,
"computed_at": "2025-09-30T06:05:00Z"
}
]
}
]
}

This data can be used to display ranked threats for each Defended Asset (DA) in the frontend.

ModelParams Admin UI:

The ModelParams model has been added to the Django admin interface, where weights, scaling factors, and other parameters like clamp_0_1 can be modified. While this part is mainly for backend management, frontend can access the ModelParams API (if needed) to fetch and display the parameters.

2. Frontend Integration Tasks
   2.1 Integrating the Threat Ranking API

The frontend team needs to fetch the ranked threats data from the backend and display it to the user.

Frontend Service:

Create a service to fetch the ranked threats from the API. This will typically be done in the Angular service layer.

// tewa.service.ts
@Injectable({
providedIn: 'root'
})
export class TewaService {
private apiBase = '/api/tewa';

constructor(private http: HttpClient) { }

// Get ranking of threats (top N)
getRanking(scenarioId: number, topN: number): Observable<any> {
return this.http.get(`${this.apiBase}/ranking/?scenario_id=${scenarioId}&top_n=${topN}`);
}
}

Frontend Component:

In your component, you will subscribe to this service to fetch the ranked threats.

// ranking-table.component.ts
@Component({
selector: 'app-ranking-table',
templateUrl: './ranking-table.component.html',
styleUrls: ['./ranking-table.component.css']
})
export class RankingTableComponent implements OnInit {
ranking: any[] = [];

constructor(private tewaService: TewaService) {}

ngOnInit(): void {
this.fetchRanking();
setInterval(() => {
this.fetchRanking();
}, 5000); // Poll every 5 seconds
}

fetchRanking(): void {
this.tewaService.getRanking(1, 10).subscribe((data: any) => {
this.ranking = data.ranked_threats;
});
}
}

HTML Template for Display:

Display the ranked threats in a table.

<div *ngFor="let da of ranking">
  <h3>{{ da.da_name }}</h3>
  <table>
    <tr>
      <th>Track ID</th>
      <th>Threat Score</th>
      <th>Computed At</th>
    </tr>
    <tr *ngFor="let threat of da.threats">
      <td>{{ threat.track_id }}</td>
      <td>{{ threat.score }}</td>
      <td>{{ threat.computed_at }}</td>
    </tr>
  </table>
</div>

2.2 User Interaction Flow for Ranking Data

The ranking data will be displayed in a table, where each Defended Asset (DA) will have a list of ranked threats. The user can view the top-N threats for each DA and globally. You can further enhance the UI by adding:

Sorting: Allow users to sort by threat score or computed time.

Pagination: If the number of threats grows large, you can implement pagination.

Refreshing: Automatically refresh the rankings at intervals or allow users to refresh manually.

2.3 Fetching and Displaying ModelParams

While the ModelParams model is primarily used for managing parameters through the admin interface, you might want to display the values of parameters like weights and scaling factors on the frontend.

API Endpoint (If exposed):

If you expose the ModelParams model via an API (e.g., /api/tewa/modelparams/), you can fetch and display the parameters like this:

// tewa.service.ts
getModelParams(scenarioId: number): Observable<any> {
return this.http.get(`${this.apiBase}/modelparams/?scenario_id=${scenarioId}`);
}

Frontend Component for Displaying ModelParams:

In the ModelParamsComponent, display the weights and scaling factors.

@Component({
selector: 'app-model-params',
templateUrl: './model-params.component.html',
styleUrls: ['./model-params.component.css']
})
export class ModelParamsComponent implements OnInit {
modelParams: any;

constructor(private tewaService: TewaService) {}

ngOnInit(): void {
this.fetchModelParams();
}

fetchModelParams(): void {
this.tewaService.getModelParams(1).subscribe((data: any) => {
this.modelParams = data;
});
}
}

HTML Template for ModelParams:

<div *ngIf="modelParams">
  <h3>Model Parameters for Scenario {{ modelParams.scenario.name }}</h3>
  <ul>
    <li>CPA Weight: {{ modelParams.w_cpa }}</li>
    <li>TCPA Weight: {{ modelParams.w_tcpa }}</li>
    <li>TDB Weight: {{ modelParams.w_tdb }}</li>
    <li>TWRP Weight: {{ modelParams.w_twrp }}</li>
    <li>CPA Scale (km): {{ modelParams.cpa_scale_km }}</li>
    <li>TCPA Scale (s): {{ modelParams.tcpa_scale_s }}</li>
    <li>TDB Scale (km): {{ modelParams.tdb_scale_km }}</li>
    <li>TWRP Scale (s): {{ modelParams.twrp_scale_s }}</li>
  </ul>
</div>

3. Data Flow for Frontend Team

Ranking Data:

Fetch the ranked threats for a specific DA or globally using the /api/tewa/ranking/ API.

Display the results in a table with track_id, score, and computed_at for each Defended Asset (DA) and globally.

Implement pagination and sorting for user-friendly browsing.

Model Params Data:

If ModelParams data is required, fetch the parameters (weights, scaling factors) using the /api/tewa/modelparams/ API.

Display these parameters in the UI, possibly on the ModelParams Component.

4. Testing and Validation

Before finalizing the frontend:

Test the Angular Services:

Make sure the TewaService is correctly interacting with the backend APIs.

Ensure that the ranking and ModelParams APIs return the expected data.

Test the UI:

Ensure that the ranking table and ModelParams display are working as expected.

Test responsiveness, sorting, and pagination.

5. Conclusion

For the frontend development team:

Backend API Integration: The team will use the ranking API to fetch and display ranked threats, and the ModelParams API (if exposed) to display model parameters.

UI: Use tables and lists to display the ranked threats and model parameters clearly. Add sorting and pagination to handle large datasets.

Testing: Test API calls and frontend components to ensure proper integration with the backend.

Let me know if you need further assistance with any specific frontend details or if you'd like to continue with the next steps!

Frontend Integration for Ranking API

The Ranking API has been implemented and is ready to be integrated into the frontend (Angular). Here's a detailed plan for the frontend development team to integrate the ranking feature effectively. This will include how the API will be consumed, how the data should be presented, and potential enhancements.

1. Overview of Ranking API

The Ranking API provides rankings of threats based on their computed score, which can be requested either globally (across all Defended Assets) or for a specific Defended Asset (DA).

Global Ranking: Provides a ranked list of threats for the entire scenario.

DA-Specific Ranking: Provides ranked threats specific to a particular Defended Asset (DA).

API Endpoint:

URL: /api/tewa/ranking/

Method: GET

Parameters:

scenario_id: (Required) ID of the scenario for which ranking is requested.

top_n: (Optional, default: 10) Limit the number of threats to return.

da_id: (Optional) If provided, ranks threats only for this specific Defended Asset (DA). If omitted, returns global rankings.

Example Request:

GET /api/tewa/ranking/?scenario_id=1&top_n=5&da_id=1

Response Example:

[
{
"da_name": "DA-Alpha (Jaisalmer)",
"threats": [
{
"track_id": "T2",
"score": 0.7617,
"computed_at": "2025-10-01T07:23:01.324952+00:00"
},
{
"track_id": "T1",
"score": 0.5785,
"computed_at": "2025-10-01T07:23:01.317516+00:00"
}
]
}
]

2. Frontend Implementation Steps
   Step 1: Create a Service to Fetch Ranking Data

Service Creation: Create a service in Angular to handle API calls to the ranking endpoint.

// src/app/services/ranking.service.ts

import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
providedIn: 'root'
})
export class RankingService {

private apiUrl = '/api/tewa/ranking/'; // Backend API URL

constructor(private http: HttpClient) { }

// Function to get ranking data
getRanking(scenarioId: number, topN: number = 10, daId?: number): Observable<any> {
let params = new HttpParams()
.set('scenario_id', scenarioId.toString())
.set('top_n', topN.toString());

    if (daId) {
      params = params.set('da_id', daId.toString());
    }

    return this.http.get<any>(this.apiUrl, { params });

}
}

Step 2: Create a Ranking Component

Component Creation: Create a new component to display the ranked threats.

// src/app/components/ranking/ranking.component.ts

import { Component, OnInit } from '@angular/core';
import { RankingService } from 'src/app/services/ranking.service';

@Component({
selector: 'app-ranking',
templateUrl: './ranking.component.html',
styleUrls: ['./ranking.component.css']
})
export class RankingComponent implements OnInit {
scenarioId: number = 1; // Example scenario id
topN: number = 5;
rankedThreats: any[] = [];
loading: boolean = false;
error: string | null = null;

constructor(private rankingService: RankingService) {}

ngOnInit(): void {
this.loadRanking();
}

// Function to load the ranking data
loadRanking(): void {
this.loading = true;
this.error = null;
this.rankingService.getRanking(this.scenarioId, this.topN).subscribe(
data => {
this.rankedThreats = data;
this.loading = false;
},
err => {
this.error = 'Failed to load ranking data';
this.loading = false;
}
);
}
}

Step 3: Create a Ranking Component HTML Template

Template: Display the ranking data in a table format.

<!-- src/app/components/ranking/ranking.component.html -->

<div *ngIf="loading">Loading ranking data...</div>
<div *ngIf="error" class="error">{{ error }}</div>

<table *ngIf="!loading && rankedThreats.length > 0" class="table table-striped">
  <thead>
    <tr>
      <th>Defended Asset</th>
      <th>Track ID</th>
      <th>Threat Score</th>
      <th>Computed At</th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let da of rankedThreats">
      <td colspan="4"><strong>{{ da.da_name }}</strong></td>
    </tr>
    <tr *ngFor="let threat of da.threats">
      <td></td>
      <td>{{ threat.track_id }}</td>
      <td>{{ threat.score }}</td>
      <td>{{ threat.computed_at }}</td>
    </tr>
  </tbody>
</table>

<div *ngIf="rankedThreats.length === 0 && !loading">No threats to display.</div>

Step 4: Add Styling (Optional)

CSS Styling: Customize the appearance of the table for better clarity.

/_ src/app/components/ranking/ranking.component.css _/

table {
width: 100%;
margin-top: 20px;
}

table th, table td {
padding: 12px;
text-align: left;
}

table th {
background-color: #f4f4f4;
}

.error {
color: red;
margin-top: 20px;
}

3. Frontend Flow

Page Load: When the page is loaded, the RankingComponent will call the getRanking function from the RankingService to fetch data.

Displaying Data: The component will display the ranked threats in a table format, showing details like track_id, score, and computed_at.

Handling Errors: If the API call fails, an error message will be shown.

Pagination: If you have a lot of threats, consider implementing pagination or infinite scroll.

4. Next Steps for Frontend Team

Implement the Ranking Component: Follow the steps above to create the service and component. Ensure the API call is working by checking the response in the console.

Customize UI: Based on the data received, customize the table layout and styling as per the design requirements.

Integrate with Other Pages: Once the component is ready, integrate it into the relevant sections of your application (e.g., dashboard, reports).

Test the API: Use Postman or Browser to ensure the ranking API is working as expected. You can also perform load testing for large datasets.

5. Conclusion

Service: The Angular service fetches ranked threat data from the API.

Component: The RankingComponent displays the data in a responsive and clean format.

UI/UX: A simple table with pagination or infinite scroll can be added if needed.

Once the frontend team integrates this, the ranking feature will be fully operational. Let me kn

Task 19: Defended Asset (DA) CRUD
Objective

Allow users to view, select, create, edit, and delete Defended Assets (DA) for TEWA scenarios.

Users can select pre-added DAs (DA-Alpha, DA-Bravo).

Users can add new DAs, which are persisted in the PostgreSQL database and visible immediately in the frontend.

1. Database & Model

Model: DefendedAsset

Field	Type	Description
id	Integer	Auto-generated primary key
name	CharField	Name of the DA (e.g., "DA-Alpha (Jaisalmer)")
lat	FloatField	Latitude of the DA
lon	FloatField	Longitude of the DA
radius_km	FloatField	Effective radius of the DA (km)
created_at	DateTime	Auto-generated timestamp when DA was created
updated_at	DateTime	Auto-updated timestamp when DA is modified

Constant pre-added DAs:

[
  {
    "id": 1,
    "name": "DA-Alpha (Jaisalmer)",
    "lat": 26.889045927834,
    "lon": 70.86392327099402,
    "radius_km": 25.0
  },
  {
    "id": 2,
    "name": "DA-Bravo (Jodhpur)",
    "lat": 26.2389,
    "lon": 73.0243,
    "radius_km": 30.0
  }
]

2. Backend API Endpoints
Action	Method	Endpoint	Request Body	Response
List all DAs	GET	/api/tewa/das/	N/A	Array of DA objects (id, name, lat, lon, radius_km, timestamps)
Create a new DA	POST	/api/tewa/das/	{ "name": string, "lat": float, "lon": float, "radius_km": float }	Newly created DA object with ID and timestamps
Edit existing DA	PUT/PATCH	/api/tewa/das/<id>/	Updated fields: name, lat, lon, radius_km	Updated DA object
Delete DA	DELETE	/api/tewa/das/<id>/	N/A	Status 204 No Content

Example: Add a new DA

POST /api/tewa/das/
{
  "name": "DA-Charlie (Bikaner)",
  "lat": 28.0229,
  "lon": 73.3119,
  "radius_km": 20.0
}


Response:

{
  "id": 3,
  "name": "DA-Charlie (Bikaner)",
  "lat": 28.0229,
  "lon": 73.3119,
  "radius_km": 20,
  "created_at": "2025-10-08T14:27:16Z",
  "updated_at": "2025-10-08T14:27:16Z"
}

3. Frontend Angular Integration
DA Selection Dropdown

Fetch DA list on page load using GET /api/tewa/das/.

Populate a <select> dropdown with id as the value and name as the label.

this.tewaService.listDefendedAssets().subscribe(das => {
  this.defendedAssets = das; // Bind to dropdown
});

<select [(ngModel)]="selectedDaId">
  <option *ngFor="let da of defendedAssets" [value]="da.id">{{ da.name }}</option>
</select>

Add New DA Form

Inputs: name, lat, lon, radius_km.

Submit POST request to /api/tewa/das/.

On success, refresh DA list in dropdown to include newly created DA.

this.tewaService.createDefendedAsset(newDA).subscribe(res => {
  this.defendedAssets.push(res); // Update list dynamically
});

Validation Rules

radius_km must be between 0.1 km and 1000 km.

Latitude: -90 to 90

Longitude: -180 to 180

Name: required, max length 128 chars

User Flow

Select existing DA for scenario or track → bind selectedDaId.

Add new DA → API POST → refresh dropdown → select newly created DA.

Edit DA (optional) → open edit form → submit PUT/PATCH → update table/dropdown.

Delete DA → confirm → API DELETE → remove from list.

4. Notes for Frontend Team

All DAs are persisted in PostgreSQL, so data is consistent across sessions.

Pre-added DAs (DA-Alpha, DA-Bravo) must always be available.

New DAs are visible immediately after creation.

Can be integrated with Scenario Detail Page (Task 18) for assigning DAs to tracks.

This document ensures your frontend team knows:

How to fetch DA data from backend

How to display it in dropdowns

How to create new DAs

Validation rules

Backend endpoints to call


Next Steps for the Frontend Team:

Use /api/tewa/tracks/?track_id=<TRACK_ID>&scenario_id=<SCENARIO_ID> for filtered track listing.

Use /api/tewa/tracks/<TRACK_ID>/ for individual track details.

Combine with scenario and DA endpoints for the UI to show:

Scenario → Tracks → DA → Threat scores.

The search/filter functionality can be implemented on Angular by calling these APIs with user input for track_id or scenario_id.
