TEWA (Threat Evaluation & Weapon Assignment) — End-to-End Handover (as of 2025-10-06)

This is a single, self-contained brief that explains what’s built, how it’s structured, and key decisions/fixes we made while wiring the Angular frontend to the Django backend. You can give this doc to another AI/dev and they’ll be able to reason about the system and continue from here.

1. Tech stack & topology

Backend: Python 3.10, Django 5.1.x, PostgreSQL, Celery (planned / partial), DRF-style endpoints under /api/tewa/.

Frontend: Angular (standalone bootstrap with provideRouter), TypeScript, optional Angular Material, Leaflet for maps.

Runtime: Backend uses UTC for all persisted datetimes; frontend sends/reads ISO-8601 with Z.

2. Repo layout (backend)
   missile_model/
   ├─ manage.py
   ├─ missile_model/
   │ ├─ settings.py
   │ ├─ urls.py # includes tewa URLs under /api/tewa/
   │ ├─ wsgi.py / asgi.py
   │ └─ celery.py # scaffolding for periodic tasks
   ├─ core/
   │ ├─ utils/
   │ │ ├─ units.py # unit conversions
   │ │ └─ geodesy.py # haversine, bearings, ENU mapping
   │ └─ tests/ # conversions, geodesy, kinematics, scoring
   └─ tewa/
   ├─ models.py # Scenario, DefendedAsset, Track, TrackSample, ModelParams, ThreatScore
   ├─ admin.py, serializers.py, forms.py
   ├─ views.py, urls.py
   ├─ tasks.py # Celery entrypoints (periodic compute)
   ├─ services/
   │ ├─ engine.py # time-aware scenario engine
   │ ├─ kinematics.py # CPA/TCPA/TDB/TWRP
   │ ├─ normalize.py # clamp01, inv1
   │ ├─ scoring.py # weights/scales -> final score
   │ ├─ threat_compute.py # per-track compute + persistence
   │ ├─ sampling.py # linear/latest sampling between TrackSamples
   │ └─ csv_import.py # (rewritten) robust CSV importer with UTC timestamps
   ├─ management/commands/
   │ ├─ seed_demo.py
   │ ├─ import_tracks.py
   │ └─ compute_threats.py
   ├─ fixtures/tewa_seed.json
   └─ tests/

Data model essentials

Scenario: name, start_time, end_time, notes.

DefendedAsset: name, lat, lon, radius_km.

Track: (scenario FK), track_id + snapshot fields (lat, lon, alt_m, speed_mps, heading_deg).

TrackSample: (track FK) + t (timestamp) + kinematic snapshot.

ModelParams: weights & scales for CPA/TCPA/TDB/TWRP normalization.

ThreatScore: per (scenario, track, da, computed_at) with raw components + score ∈ [0..1].

Indexes exist for efficient queries by scenario/DA/track and time.

3. Backend APIs (current)

All paths prefixed with /api/tewa/.

GET /scenarios/ — list scenarios for dropdowns.

POST /upload_tracks/ — CSV upload (see importer below). Returns summary.

POST /compute_now/ — compute for “now” using current Track snapshots.

POST /compute_at/ — compute at a given ISO time (when), optional da_ids, method linear|latest.

GET /score/ — list persisted ThreatScore rows, filter by ?scenario_id&da_id.

GET /ranking/ — (optional) top-N ranked threats by scenario (and optionally DA).

We also expose /api/ (root list) and /api/health (ping).

Contracts (canonical shapes)

Compute at (request)

{
"scenario_id": 1,
"when": "2025-09-30T06:07:30Z",
"da_ids": [1, 2],
"method": "linear",
"weapon_range_km": 20
}

Ranking (response)

{
"scenario_id": 1,
"threats": [
{"track_id":"T2","da_name":"DA-Alpha","score":0.7617,"computed_at":"2025-10-01T07:23:01Z"}
]
}

Score row (typical view)

{ "track_id": "T1", "da_name": "DA-Alpha", "score": 0.578, "computed_at": "2025-09-30T06:07:30Z" }

4. CSV upload pipeline (backend)
   Problem solved: Naive datetime warnings

Django logs showed:

RuntimeWarning: DateTimeField TrackSample.t received a naive datetime (...)

because CSV timestamps lacked timezone info. We rewrote the importer to coerce all timestamps to UTC-aware datetimes.

Current importer (summary)

tewa/services/csv_import.py:

Validates headers: track_id, lat, lon, alt_m, speed_mps, heading_deg, timestamp.

Parses timestamp via \_parse_ts_aware_utc():

accepts Z (UTC), offsets (+05:30), or naive (treated as UTC).

Creates or finds Track (prefers (scenario, track_id) if scenario present).

Creates TrackSample with tz-aware UTC t.

Updates the Track “snapshot” fields to the latest row encountered.

Returns summary:

{"message":"Upload ok","tracks_created":X,"samples_created":Y,"rows_processed":Z,"errors":[...]}

Upload view calls the importer and returns this summary. Result: warnings gone and data consistent.

Tip for CSV authors: always include Z in timestamps (2025-09-30T06:05:00Z).

5. Kinematics & scoring (backend)

kinematics.py:

CPA/TCPA via straight-line motion in a local ENU frame.

TDB (to DA boundary circle).

TWRP (to weapon release range ring).

normalize.py: inv1(x, scale) = 1/(1+x/scale) + clamp01.

threat_compute.py: apply normalization weights from ModelParams, write ThreatScore. Negative TCPA (closest approach in the past) is down-weighted.

engine.py: time-aware computation over sampled tracks at when using method="linear|latest".

6. Frontend structure
   Boot & routing

Standalone bootstrap with provideRouter(routes) in app.config.ts.

Root component (app.component.ts) contains <router-outlet> and a tiny nav.

Routes (src/app/app.routes.ts)

export const routes: Routes = [
{ path: '', redirectTo: 'tewa/upload-tracks', pathMatch: 'full' },
{ path: 'tewa', loadChildren: () => import('./tewa/tewa.module').then(m => m.TewaModule) },
{ path: 'control', loadComponent: () => import('./tewa-control/tewa-control.component').then(m => m.TewaControlComponent) },
{ path: 'compute', loadComponent: () => import('./tewa-compute/tewa-compute.component').then(m => m.TewaComputeComponent) },
{ path: '**', redirectTo: 'tewa/upload-tracks' },
];

TewaModule (src/app/tewa/tewa.module.ts) defines child routes without prefix:

const routes: Routes = [
{ path: '', component: TewaDashboardComponent },
{ path: 'upload-tracks', component: TrackUploadComponent },
];

Environment & API paths

src/environments/environment.ts:

export const environment = {
production: false,
apiBase: '/api/tewa',
paths: {
computeNow: '/compute_now/',
computeAt: '/compute_at/',
score: '/score/',
da: '/da/', // or 'das' depending on backend
scenarios: '/scenarios/',
tracks: '/tracks/',
tracksamples: '/tracksamples/',
ranking: '/ranking/',
uploadTracks: '/upload_tracks/',
},
};

We normalized on TewaService as the single API client.

Models (frontend)

src/app/core/models/tewa.models.ts defines:

Scenario, DefendedAsset, Track, TrackSample, ModelParams

ThreatScore and view/row helpers

ComputeResponse, RankingResponse

Service (frontend)

src/app/core/services/tewa.service.ts exposes:

Lists

getScenarios(): Observable<Scenario[]>

listDefendedAssets({scenario_id}?): Observable<DefendedAsset[]>

getThreatScores(scenarioId?, daId?)

getTracksByScenario(scenarioId)

Compute

computeNow(scenarioId, daId?, weaponRangeKm?)

computeAt(scenarioId, whenIso, daIds?, method='linear'|'latest', weaponRangeKm?)

calculateScores(scenarioId, timestampIso, weaponRangeKm?) (if backend exposes /calculate_scores/)

Ranking / threats

getRanking(scenarioId, daId?, topN=10)

listThreats(scenarioId, daId?, ordering?, page?, pageSize?)

Uploads

uploadTracks(file: File, scenarioId?): Observable<HttpEvent<any>>

Emits UploadProgress and final Response.

Components

TrackUploadComponent

CSV file input + drag-drop, MIME/extension check.

Calls uploadTracks(File, scenarioId?), shows progress via HttpEventType.UploadProgress.

Success/error messaging driven by server JSON (summary surfaced).

TewaControlComponent (standalone)

Scenario dropdown (GET /scenarios/).

“Compute Now” button (POST /compute_now/), then fetches scores (GET /score/).

CSV upload (progress bar, success toast).

Keeps UI state flags (isComputing, isUploading, etc).

TewaComputeComponent (standalone)

Compute at time (computeAt) and now (computeNow) with params (method, weapon_range, da filters).

Fetches ranking after compute (getRanking).

Also supports CSV upload (same File-based pattern).

RankingTableComponent (standalone)

Polls getRanking(scenarioId, daId?, topN) every 5s (configurable).

Loads DA list via listDefendedAssets() for filtering.

TewaMapComponent

Leaflet map rendering of:

DAs as circles with radius_km.

Tracks as markers labeled with track_id & heading.

Installed: leaflet and @types/leaflet; added @import "leaflet/dist/leaflet.css"; at the top of src/styles.css.

Frontend pitfalls fixed

Duplicate routes in app.routes.ts → removed.

Root white page → ensured <router-outlet> in root, correct redirects, and standalone bootstrap via bootstrapApplication.

CSS import order → @import must be first in styles.css.

Bad upload signature → service now expects a File; component subscribes to HttpEvent and uses HttpEventType to compute progress.

Service method mismatch → replaced old listDA() with listDefendedAssets(...).

Missing typings → installed @types/leaflet.

Dev proxy

ng serve --proxy-config proxy.conf.json is used so that frontend /api/tewa/... requests are proxied to Django on http://127.0.0.1:8000.

7. Time & timezone policy

Backend: USE_TZ=True, TIME_ZONE='UTC'.

Importer: All CSV timestamps are coerced to UTC-aware datetimes.

Frontend: Always send when/timestamp as new Date().toISOString() (ends with Z).

Optionally DRF DATETIME_FORMAT = "%Y-%m-%dT%H:%M:%SZ" can be set for consistency.

We also suggested a pre_save safeguard for TrackSample that forces any naive t to become UTC-aware if someone bypasses the importer.

8. How to run (dev)

Backend

python manage.py migrate
python manage.py seed_demo # seed scenario, DAs, tracks, model params
python manage.py runserver

Open: http://127.0.0.1:8000/api/ and http://127.0.0.1:8000/api/tewa/

Frontend

npm i
npm i leaflet @types/leaflet
ng serve --proxy-config proxy.conf.json

Open: http://localhost:4200/tewa/upload-tracks (upload), /tewa (dashboard).

9. Current state checklist

✅ /api/tewa/scenarios/ returns 200 with list.

✅ CSV upload returns 200 with summary; no naive datetime warnings.

✅ Compute endpoints reachable; control/compute screens trigger compute.

✅ ThreatScore listing and Ranking table wired; polling works.

✅ Map renders DAs & Tracks (Leaflet), CSS import fixed.

✅ Angular app boots via bootstrapApplication, correct routes visible.

10. Design choices that inform future answers

Deterministic kinematics only; no intent/aircraft-type modelling (fast and predictable).

Straight-line ENU model is acceptable for short horizons. (We do interpolation of states for compute_at.)

Normalization with inv1 gives smooth bounded contributions; final score clamped to [0..1].

TCPA < 0 indicates event in the past → down-weight urgency in scoring.

ThreatScore persisted so ranking & history can be queried efficiently. Indexes in place for scenario/DA/time.

11. Known gaps / “next” items

Add /calculate_scores/ endpoint if we want a pure compute response (no persistence), already supported in TewaService.

DA management UI (create/edit) with validation (0 < radius_km ≤ 1000).

Optional scenario-scoped DA list: /scenarios/{id}/das/.

Celery Beat to periodically refresh ThreatScore (auto ranking updates).

Pagination & filters on /score/, plus CSV/Excel export.

Better surfacing of row-level CSV errors in the upload UI (collapsible details).

Consolidate any lingering uses of TewaApiService to the unified TewaService.

12. Minimal contract snippets (for another AI)

Environment constants

apiBase = "/api/tewa";
paths = {
scenarios: "/scenarios/",
uploadTracks: "/upload_tracks/",
computeNow: "/compute_now/",
computeAt: "/compute_at/",
score: "/score/",
ranking: "/ranking/",
da: "/da/" // or 'das' in some deployments
};

Upload (frontend)

Pass File and optional scenario_id:

Expect HttpEvent stream: show UploadProgress; on Response, read summary {tracks_created, samples_created, rows_processed, errors[]}.

Importer (backend)

Parse timestamp → tz-aware UTC.

Create or update Track (prefer by scenario when present).

Create TrackSample.

Return summary as JSON.

Compute

Now: POST /compute_now/ { "scenario_id": number, "da_id"?, "weapon_range_km"? }

At: POST /compute_at/ { "scenario_id": number, "when": iso, "da_ids"?, "method"?, "weapon_range_km"? }

Ranking

GET /ranking/?scenario_id=1&da_id=2&top_n=10
